# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Threshold an image using Huang's fuzzy thresholding method.
#'
#' Implements Huang's fuzzy thresholding method. This function is called by 
#' the \code{\link{threshold}} function. It is not intended to be used 
#' directly.
#'
#' Ported to C++ by from the code in the Auto_threshold imageJ plugin by 
#' Gabriel Landini.
#'
#' See original code at:
#' http://www.mecourse.com/landinig/software/autothreshold/autothreshold.html
#'
#' @param data the input image
#' @return integer threshold value
#' @references Huang, L.-K., and M.-J. J. Wang. 1995. Image thresholding by 
#' minimizing the measures of fuzziness. Pattern recognition 28 (1):41--51.
threshold_Huang <- function(data) {
    .Call('teamlucc_threshold_Huang', PACKAGE = 'teamlucc', data)
}

#' Calculate change direction
#'
#' This code calculate the change direction from two probability images. Not
#' intended to be called directly - see \code{chg_dir}.
#'
#' @export
#' @param t1p time 1 posterior probability matrix (with pixels in rows, bands 
#' in columns)
#' @param t2p time 2 posterior probability matrix (with pixels in rows, bands 
#' in columns)
#' @return vector of change directions
#' @references Chen, J., P. Gong, C. He, R. Pu, and P. Shi. 2003.
#' Land-use/land-cover change detection using improved change-vector analysis.
#' Photogrammetric Engineering and Remote Sensing 69:369-380.
#' 
#' Chen, J., X. Chen, X. Cui, and J. Chen. 2011. Change vector analysis in 
#' posterior probability space: a new method for land cover change detection.  
#' IEEE Geoscience and Remote Sensing Letters 8:317-321.
calc_chg_dir <- function(t1p, t2p) {
    .Call('teamlucc_calc_chg_dir', PACKAGE = 'teamlucc', t1p, t2p)
}

#' Cloud fill using the algorithm developed by Xiaolin Zhu
#'
#' This function is called by the \code{\link{cloud_remove}} function. It is
#' not intended to be used directly.
#'
#' @param cloudy the cloudy image as a matrix, with pixels in columns (in 
#' column-major order) and with number of columns equal to number of bands
#' @param clear the clear image as a matrix, with pixels in columns (in 
#' column-major order) and with number of columns equal to number of bands
#' @param cloud_mask the cloud mask image as a vector (in column-major order), 
#' with clouds coded with unique integer codes starting at 1, and with areas 
#' that are clear in both images  coded as 0. Areas that are missing in the 
#' clear image, should be coded as -1.
#' @param dims the dimensions of the cloudy image as a length 3 vector: (rows, 
#' columns, bands)
#' @param num_class set the estimated number of classes in image
#' @param min_pixel the sample size of similar pixels
#' @param max_pixel the maximum sample size to search for similar pixels
#' @param cloud_nbh the range of cloud neighborhood (in pixels)
#' @param DN_min the minimum valid DN value
#' @param DN_max the maximum valid DN value
#' @param verbose whether to print detailed status messages
#' @return array with cloud filled image with dims: cols, rows, bands
#' parameter, containing the selected textures measures
#' @references Zhu, X., Gao, F., Liu, D., Chen, J., 2012. A modified
#' neighborhood similar pixel interpolator approach for removing thick clouds 
#' in Landsat images. Geoscience and Remote Sensing Letters, IEEE 9, 521--525.
cloud_fill <- function(cloudy, clear, cloud_mask, dims, num_class, min_pixel, max_pixel, cloud_nbh, DN_min, DN_max, verbose = FALSE) {
    .Call('teamlucc_cloud_fill', PACKAGE = 'teamlucc', cloudy, clear, cloud_mask, dims, num_class, min_pixel, max_pixel, cloud_nbh, DN_min, DN_max, verbose)
}

#' Cloud fill using a simple linear model approach
#'
#' This algorithm fills clouds using a simple approach in which the value of 
#' each clouded pixel is calculated using a linear model. The script
#' develops a separate linear model (with slope and intercept) for each band 
#' and each cloud. For each cloud, and each image band, the script finds all 
#' pixels clear in both the cloudy and fill images, and calculates a 
#' regression model in which pixel values in the fill image are the 
#' independent variable, and pixel values in the clouded image are the 
#' dependent variable. The script then uses this model to predict pixel values 
#' for each band in each cloud in the clouded image.
#'
#' This function is called by the \code{\link{cloud_remove}} function. It is
#' not intended to be used directly.
#'
#' @param cloudy the cloudy image as a matrix, with pixels in columns (in 
#' column-major order) and with number of columns equal to number of bands
#' @param clear the clear image as a matrix, with pixels in columns (in 
#' column-major order) and with number of columns equal to number of bands
#' @param cloud_mask the cloud mask image as a vector (in column-major order), 
#' with clouds coded with unique integer codes starting at 1, and with areas 
#' that are clear in both images  coded as 0. Areas that are missing in the 
#' clear image, should be coded as -1.
#' @param dims the dimensions of the cloudy image as a length 3 vector: (rows, 
#' columns, bands)
#' @param num_class set the estimated number of classes in image
#' @param cloud_nbh the range of cloud neighborhood (in pixels)
#' @param DN_min the minimum valid DN value
#' @param DN_max the maximum valid DN value
#' @param verbose whether to print detailed status messages
#' @return array with cloud filled image with dims: cols, rows, bands
#' parameter, containing the selected textures measures
cloud_fill_simple <- function(cloudy, clear, cloud_mask, dims, num_class, cloud_nbh, DN_min, DN_max, verbose = FALSE) {
    .Call('teamlucc_cloud_fill_simple', PACKAGE = 'teamlucc', cloudy, clear, cloud_mask, dims, num_class, cloud_nbh, DN_min, DN_max, verbose)
}

