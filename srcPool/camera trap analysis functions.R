#Jorge Ahumada. Tropical Ecology Assessment and Monitoring Network. Conservation International
# Code developed on 2010/07/02 - 2010/12/01
require(TeachingDemos)
require(reshape2)
require(ggplot2)
#script to process raw TEAM files and get them ready for analysis
f.readin.fix.data<-function(){
	require(lubridate)
	data<-read.csv(file.choose(),h=T,skip=62)
	data<-f.fix.data(data)
	#make sure date info makes sense
	data
	}


#function to create binary matrices for all species at a site and sampling period. Matrix has a 1 if the species was seen in a day a 0 if not seen and NA if not sampled
#The function requires data from one sampling event and will return a list composed of 0,1 matrices, one matrix for each species.

#THIS FUNCTION WORKS WITH NEW TEAM DATA ONLY - do not use with legacy TEAM data
# this works one year at a time. Separate data in different years first
f.matrix.creator2<-function(data,year){
  #results object
  res<-list()
  
  #get the dimensions of the matrix
  
  #list if sanpling units
  cams<-unique(data$Sampling.Unit.Name)
  cams<-sort(cams)
  rows<-length(cams)
  species<-unique(data$bin)
  #start and end dates of sampling periods
  data<-data[data$Sampling.Period==year,]
  min<-min(data$Start.Date)
  max<-max(data$End.Date)
  cols<-max-min+1
  
  #sampling period
  date.header<-seq(from=min,to=max, by="days")
  mat<-matrix(NA,rows,cols,dimnames=list(cams,as.character(date.header)))
  
  #for all cameras, determine the open and close date and mark in the matrix
  start.dates<-tapply(as.character(data$Start.Date),data$Sampling.Unit.Name,unique)
  nms<-names(start.dates)
  start.dates<-ymd(start.dates)
  names(start.dates)<-nms
  end.dates<-tapply(as.character(data$End.Date),data$Sampling.Unit.Name,unique)
  end.dates<-ymd(end.dates)
  names(end.dates)<-nms
  
  #outline the sampling periods for each camera j
  for(j in 1:length(start.dates)){
    #for each camera beginning and end of sampling
    low<-which(date.header==start.dates[j])
    hi<-which(date.header==end.dates[j])
    if(length(low)+length(hi)>0){
      indx<-seq(from=low,to=hi)
      mat[names(start.dates)[j],indx]<-0
    } else next
  }
  mat.template<-mat
  #get the species
  #species<-unique(data$bin)
  #construct the matrix for each species i
  for(i in 1:length(species)){
    indx<-which(data$bin==species[i])
    #dates and cameras when/where the species was photographed
    dates<-data$Photo.Date[indx]
    cameras<-data$Sampling.Unit.Name[indx]
    dates.cameras<-data.frame(dates,cameras)
    #unique combination of dates and cameras 
    dates.cameras<-unique(dates.cameras)
    #fill in the matrix
    for(j in 1:length(dates.cameras[,1])){
      col<-which(date.header==dates.cameras[j,1])
      row<-which(cams==dates.cameras[j,2])
      mat[row,col]<-1
    }
    mat.nas<-is.na(mat)
    sum.nas<-apply(mat.nas,2,sum)
    indx.nas<-which(sum.nas==rows)
    if(length(indx.nas)>0){
      mat<-mat[,-indx.nas]
    }
    
    res<-c(res,list(mat))
    #return the matrix to its original form
    mat<-mat.template
  }
  
  names(res)<-species
  #res<-lapply(res,f.dum)
  res
  
}

f.check.NA.breaks<-function(vector){
	notna<-which(!is.na(vector))
	if(min(notna)+length(notna)-1==max(notna)) print("ok")
	else print("aggh")
	}
	
f.start.minus.end<-function(data){
	data$End.Date-data$Start.Date
	}
f.start<-function(data){
	data$Start.Date
	}
f.end<-function(data){
	data$End.Date
	}

f.picture.dates<-function(data){
	data$Photo.Date
	}
f.picture.span <-function(data){
	max(data)-min(data)
	}
f.picture.min<-function(data){
	min(data)
	}
f.picture.max<-function(data){
	max(data)
	}
#function to fix the start/stop time of a camera if it is incorrectly entered	
f.start.stop.date.fixer<-function(data){
	
	cam.start.date<-by(data,data$Sampling.Unit.Name,f.start)
	cam.start.date<-lapply(cam.start.date,unique)
	cam.end.date<-by(data,data$Sampling.Unit.Name,f.end)
	cam.end.date<-lapply(cam.end.date,unique)
	
	#cam.span<-(by(data,data$Sampling.Unit.Name,f.start.minus.end))
	#cam.span<-lapply(cam.span,unique)
	
	pic.span<-by(data,data$Sampling.Unit.Name,f.picture.dates)
	min.pic<-lapply(pic.span,f.picture.min)
	max.pic<-lapply(pic.span,f.picture.max)
	#pic.span<-lapply(pic.span,f.picture.span)
	
	indx<-which(as.numeric(cam.start.date)-as.numeric(min.pic)>0 |as.numeric(cam.end.date)-as.numeric(max.pic)<0)
	#figure out which camera has the problem
	#indx<-which(as.numeric(cam.span)-as.numeric(pic.span)<=0)
	if(length(indx)){
	{cam.id<-names(pic.span)[indx]
	print("There are problems with the following cameras:")
	print(cam.id)}
	#for(i in 1:length(indx)){
	#	index<-which(data$Sampling.Unit.Name==cam.id[i])
	#	data$Start.Date[index]<-min.pic[[indx[i]]]
	#	data$End.Date[index]<-max.pic[[indx[i]]]
	#	
	#	}
		}
		else
			print("No problems detected..")
	#data
	}	
#function to convert a list of sampling matrices generated by f.matrix.creator2 into a data frame that can be used by the unmarked package	
f.convert.to.unmarked<-function(list){
require(unmarked)
nspecies<-length(list)
nrows<-dim(list[[1]])[1]
ncols<-dim(list[[1]])[2]
oldmat<-list()

for(i in 1:nspecies){
	mat<-rbind(oldmat,list[[i]])
	oldmat<-mat
	}	
y<-as.matrix(mat[,-ncols])
rownames(y)<-NULL
colnames(y)<-NULL
species<-gl(n=nspecies,k=nrows,labels=names(list))
siteCovs<-as.data.frame(species)
unmarkedFrameOccu(y=y,siteCovs=siteCovs)	
	}
	
	f.correct.DF<-function(DF){
ind <- sapply(DF, is.factor)
DF[ind] <- lapply(DF[ind], "[", drop=TRUE)
DF
	}


f.fix.data <- function(data){
  require(lubridate)
#This function converts the dates and times in the data into date and time
  data$Photo.Date<-ymd(as.character(data$Photo.Date))
	data$Photo.Time<-hms(as.character(data$Photo.Time))
	#this line stores the date and time info for each photo into a single object
  time.date<-ymd_hms(paste(data$Photo.Date,data$Photo.Time,sep=""))
	#split the date from the time for the Camera start date and time
  data$Camera.Start.Date.and.Time<-ymd_hms(as.character(data$Camera.Start.Date.and.Time))
  qwe<-data$Camera.Start.Date.and.Time
  qwe2<-ymd(paste(year(qwe),"-",month(qwe),"-",day(qwe),sep=""))
  data<-data.frame(data,Start.Date=qwe2)
	
	#Now do the same but for the End date and time of each camera trap
  #qwe<-strsplit(as.character(data$Camera.End.Date.and.Time)," ",fixed=T)
  data$Camera.End.Date.and.Time<-ymd_hms(as.character(data$Camera.End.Date.and.Time))
	qwe<-data$Camera.End.Date.and.Time
  qwe2<-ymd(paste(year(qwe),"-",month(qwe),"-",day(qwe),sep=""))
  data<-data.frame(data,End.Date=qwe2)
	#create new variable with binomial - genus species
  bin<-paste(data$Genus,data$Species)
	data<-data.frame(data,bin=bin,td.photo=time.date)
  data
	}
# This works with data downloaded from the database, not from the TEAM website
f.fix.data2 <- function(data){
  require(lubridate)
  #This function converts the dates and times in the data into date and time
  #data$Photo.Date<-ymd(as.character(data$Photo.Date))
  #data$Photo.Time<-hms(as.character(data$Photo.Time))
  #this line stores the date and time info for each photo into a single object
  time.date<-ymd_hms(as.character(data$Photo.Taken.Time))
  data$Photo.Date<-ymd(paste(year(time.date),"-",month(time.date),"-",day(time.date),sep=""))
  #split the date from the time for the Camera start date and time
  data$Camera.Start.Date.and.Time<-ymd_hms(as.character(data$Camera.Start.Date.and.Time))
  qwe<-data$Camera.Start.Date.and.Time
  qwe2<-ymd(paste(year(qwe),"-",month(qwe),"-",day(qwe),sep=""))
  data<-data.frame(data,Start.Date=qwe2)
  
  #Now do the same but for the End date and time of each camera trap
  #qwe<-strsplit(as.character(data$Camera.End.Date.and.Time)," ",fixed=T)
  data$Camera.End.Date.and.Time<-ymd_hms(as.character(data$Camera.End.Date.and.Time))
  qwe<-data$Camera.End.Date.and.Time
  qwe2<-ymd(paste(year(qwe),"-",month(qwe),"-",day(qwe),sep=""))
  data<-data.frame(data,End.Date=qwe2)
  #create new variable with binomial - genus species
  bin<-paste(data$Genus,data$Species)
  data<-data.frame(data,bin=bin,td.photo=time.date)
  data
}
f.dum<-function(data){
	dum<-apply(data,1,sum,na.rm=T)
	dum<-ifelse(dum>0,0,1)
	data<-data.frame(data,dum=dum)
	data
	}
f.extract.rare.sp<-function(raredata,alldata){
	spnum<-length(raredata[,1])
	oldindx<-numeric()
	for(i in 1:spnum){
		
		indx<-c(oldindx,which(alldata@siteCovs$species==as.character(raredata[i,1])))
		oldindx<-indx
		}
	sp<-siteCovs(alldata)[indx,]
	sp<-factor(sp)
	newufframe<-unmarkedFrameOccu(y=getY(alldata)[indx,],siteCovs=data.frame(species=sp))
	newufframe
	}

#Separate independent photographic events for a species in a given camera trap and date. thresh gives the threshold for considering events separate
#thresh is in minutes
f.separate<-function(data,thresh){
	
	#diff(data$td.photo)
	l<-length(data)
	interval<-diff(data)#abs(c(data[2:l],NA)-data)
	interval<-interval/60 #convert to minutes
	interval<-as.numeric(interval)
  ev<-1;res<-numeric()
	cond<-interval>thresh #about 5 minutes in between events
	for(i in 1:(l-1)){
		if(!cond[i]) ev<-ev
		else ev<-ev+1
		res<-c(res,ev)
		
		}
	c(1,res)
	}
#test function; not usually used	
f.test.sep<-function(cond){
	l<-length(cond)
	#interval<-c(data$Photo.Time[2:l],NA)-data$Photo.Time
	ev<-1;res<-numeric()
	#cond<-interval>5
	for(i in 1:(l-1)){
		if(!cond[i]) ev<-ev
		else ev<-ev+1
		res<-c(res,ev)
		
		}
	c(1,res)

	
	}
	
#Order the data by Sampling unit name and photo raw name. This will order images chronologically
f.order.data<-function(data){
	indx<-order(data$Sampling.Period,data$Sampling.Unit.Name,data$Photo.Taken.Time)
	data<-data[indx,]
	data
	}
#function to separate independent events, extract from the list and paste together with the data set.
#This function removes records that are NOT images.. e.g. Sampling Date records
f.separate.events<-function(data,thresh){
	
	#e.data<-by(data$td.photo,data$Sampling.Unit.Name,f.separate,thresh)
  indx<-which(is.na(data$Photo.Taken.Time))
  if(length(indx)>0)
    data<-data[-indx,]
  e.data<-f.separate(data$Photo.Taken.Time,thresh)
#e.data<-data.frame(grp=unlist(e.data))
data.frame(data,grp=paste(data$Sampling.Period,".",data$Sampling.Unit.Name,".",e.data,sep=""))

	}
#Simulation to explore the effect of changing the threshold on the number
# of independent events. Thresh range is given as a sequence in mins
f.sim.thres<-function(data,threshRange){
  qwe<-data[,-42]
  res<-data.frame(thresh=threshRange,n.events=NA)
  for(i in threshRange){
  qwe<-f.separate.events(qwe,threshRange[i])
  res[i,2]<-length(unique(qwe[,42]))
  qwe<-qwe[,-42]
  qwe<-f.correct.DF(qwe)
  }
  plot(res[,1],res[,2],xlab="Threshold (min)",ylab="Number of events",type='b')
  res
  }
  
#convert Farenheit to Celsius

f.FtoC<-function(temp) {
  round(5/9*(temp-32))
}

#extract temperatures for a given species and graph
f.extract.temp<-function(data,species) {
  qwe<-data[data$bin==species,]
  qwe<-f.correct.DF(qwe)
  res<-as.numeric(by(qwe$Temp,qwe$grp,mean))
  res
}

f.graph.temp<-function(species,spname,nbins) {
  par(lwd=2)
  truehist(species,xlim=c(15,35),ylim=c(0,0.25),xlab=expression(paste("Temperature (",degree,"C)",sep="")),col="blue",nbins=nbins)
  abline(v=28.6,lty=2,lwd=3)
  #abline(v=26.7,lwd=2)
  title(spname)
}

#create code to separate variables for a single event
f.events<-function(data){
  temp<-mean(data$Temperature)
  site<-unique(as.character(data$Site.Name))
  date<-min(as.character(data$Photo.Date))
  time<-min(as.character(data$Photo.Time))
  sp<-unique(as.character(data$bin))
  sun<-unique(as.character(data$Sampling.Unit.Name))
  lat<-unique(data$Latitude)
  lon<-unique(data$Longitude)
  sap<-unique(data$Sampling.Period)
  mp<-unique(data$Moon.Phase)
c(site,date,time,sap,temp,sp,sun,lat,lon,mp)
  }

#code to put together dataframe with each redcord being an event
f.events.dataframe<-function(data){
  require(chron)
  qwe<-by(data,data$grp,f.events)
  qwe<-as.data.frame(do.call("rbind",qwe))
  names(qwe)<-c("Site.Name","Date","Time","Sampling.Period","Temperature","bin","Sampling.Unit.Name","Latitude","Longitude","Moon.Phase")
  qwe$Date<-as.Date(chron(dates=as.character(qwe$Date),format=c(dates="y-m-d")))
  qwe$Time<-as.POSIXct(as.character(qwe$Time),format="%H:%M:%S")
  qwe$Temperature<-as.numeric(as.character(qwe$Temperature))
  qwe$Latitude<-as.numeric(as.character(qwe$Latitude))
  qwe$Longitude<-as.numeric(as.character(qwe$Longitude))
  qwe$Moon.Phase<-as.numeric(as.character(qwe$Moon.Phase))
  qwe
}  
  
#Code to create temperature event dataframes for a list of species.
#puts them all in a list

f.create.events.splist<-function(splist,fulldata){
  results<-list()
  for(i in 1:length(splist)){
    #Extract the data
    sp<-fulldata[fulldata$bin==splist[i],]
    sp<-f.correct.DF(sp)
    if(dim(sp)[1]<2){
      print(paste("Species ",splist[i]," has insufficient data..",sep=""))
      results<-c(results,list(NULL))
      next
    }
    #Order the data in chronological order
    sp<-f.order.data(sp)
    #Create independent observation events list with a threshold of 5 min
    sp<-f.separate.events(sp,5) 
   #Create a simplified data frame with just the events
    sp<-f.events.dataframe(sp)
    results<-c(results,list(sp))
    print(paste("Species ",splist[i]," processed..",sep=""))
  }
  names(results)<-splist
  results
  
}
f.print.graphs<-function(data){
  path="/Users/jorge/Analyses/TempTV/graphs2/"
for(i in 1:length(data)) {
  newp<-paste(path,names(data)[i],".pdf",sep="")
  pdf(newp)
  qplot(Temperature,data=data[[i]],geom="histogram",binwidth=1,main=names(data)[i])
  ggsave(newp)
}  
  
}
# funcion para asignar camaras faltantes que no tomaron fotos de animales.
# SuName,startDate y endDate deben estar entre comillas. Los demas argumentos no.
# startDate y endDate estan en format yyyy-mm-dd
f.assign.missing<-function(SuName,SuPeriod,startDate,endDate,data){
  rows<-dim(data)[1]
  
  #agregar Sampling Unit Name
  data[rows+1,3]<-SuName
  #agregar StartDate
  data[rows+1,38]<-as.Date(startDate)
  #agregar End Date
  data[rows+1,39]<-as.Date(endDate)
  #agregar sampling unit period
  data[rows+1,6]<-SuPeriod
  data
  
}

f.minusBirds<-function(data){
  indx<-which(data$Class=="AVES")
  data<-data[-indx,]
  data<-f.correct.DF(data)
}
#not reliable
#code to shrink the matrix by half
# f.shrink.matrix.half<-function(matrix){
#   #if number of columns in the matrix is even
#   if(!ncol(matrix)%%2){
#     #figure out how many columns
#     nc<-ncol(matrix)/2  
#     #disagregate into individual matrices
#     new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)
#     old.cols<-seq(1,ncol(matrix),2)
#     for(i in 1:nc){
#       #sum the rows for the column sections
#       sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum,na.rm=T)
#       #convert to 0s and 1s
#       new.matrix[,i]<-ifelse(sum.rows>=1,1,0)
#     }  
#     new.matrix
#   }
#   #if the number of columns is not even
#   else{
#     #store the first column in col1  
#     col1<-matrix[,1]
#     #convert the matrix to an even matrix
#     matrix<-matrix[,-1]
#     nc<-ncol(matrix)/2  
#     #disagregate into individual matrices
#     new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)
#     old.cols<-seq(1,ncol(matrix),2)
#     for(i in 1:nc){
#       sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum,na.rm=T)
#       new.matrix[,i]<-ifelse(sum.rows>=1,1,0)
#     }
#     cbind(col1,new.matrix)  
#   }
# }

#collapseData<-f.shrink.matrix(testData)
#umf2<-unmarkedFrameOccu(y=collapsedData)
#umf2
#fmcoll<-occu(~1 ~1,umf2)
#summary(fmcoll)
#plogis(coef(mod,"det"))
#plogis(coef(mod,"state"))
#plogis(coef(mod2,"det"))
#plogis(coef(mod2,"state"))

#code to shrink the matrix to exactly 15 columns
f.shrink.matrix.to15<-function(matrix){
  nc<-dim(matrix)[2]
  if(!nc%%15){ # of the number of columns is exactly divisible by 15
    newc<-nc%/%15
    old.cols<-seq(1,nc,newc)
    new.matrix<-matrix(NA,nr=nrow(matrix),nc=15)
    for(i in 1:15){
      new.matrix[,i]<-apply(matrix[,old.cols[i]:(old.cols[i]+newc-1)],1,max,na.rm=T)
    }
  } else{
    rem<-nc%%15
    newc<-nc%/%15
    old.cols<-seq(1,nc-rem,newc)
    new.matrix<-matrix(NA,nr=nrow(matrix),nc=15)
    for(i in 1:14)
      new.matrix[,i]<-apply(matrix[,old.cols[i]:(old.cols[i]+newc-1)],1,max,na.rm=T)
    new.matrix[,15]<-apply(matrix[,old.cols[15]:nc],1,max,na.rm=T) 
  }
  new.matrix[new.matrix=="-Inf"]<-NA
  rownames(new.matrix)<-rownames(matrix)
  new.matrix
}


#does not work
#f.shrink.matrix<-function(matrix){
  
  #disagregate into individual matrices
  #nc<-length(seq(1,ncol(matrix),9))  
  #new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)
  #rownames(new.matrix)<-rownames(matrix)  
  #old.cols<-seq(1,ncol(matrix),9)
  #for(i in 1:nc){
    #sum the rows for the column sections
  #  sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum)
    #convert to 0s and 1s
   # new.matrix[,i]<-ifelse(sum.rows>=1,1,0)
  #}  
  #new.matrix
#}

f.plot.jag.res<-function(jags,species.name,model.name){
  #naive occupancy
  naive.occ<-apply(tmp,2,sum,na.rm=T)/apply(tmp,2,function(x){length(which(!is.na(x)))})
  #plot results
  mat<-jags$BUGSoutput$summary
  #mean occupancy from model
  m.occ<-jags$BUGSoutput$mean$psi
  #median occupancy from model
  med.occ<-jags$BUGSoutput$median$psi
  #extract 95% confidence limits for occupancy
  psiCol<-which(rownames(mat)=="psi[1]")
  lo95ci<-mat[psiCol:(psiCol+3),3]
  hi95ci<-mat[psiCol:(psiCol+3),7]
  par(mfrow=c(2,1))
  plot(2009:2012,m.occ,ylim=c(0,1),type='b',xlab="year",ylab="occupancy")
  lines(2009:2012,as.numeric(lo95ci),lty=2)
  lines(2009:2012,as.numeric(hi95ci),lty=2)
  lines(2009:2012,naive.occ,col='red')
  #lines(2007:2011,med.occ,lwd=3)
  title(paste(species.name,"\n",model.name))
  
  #graph lambda
  lambdaCol<-which(rownames(mat)=="lambda[1]")
  m.lambda<-mat[lambdaCol:(lambdaCol+2),1]
  
  lo95ci<-mat[lambdaCol:(lambdaCol+2),3]
  hi95ci<-mat[lambdaCol:(lambdaCol+2),7]
  plot(1:3,m.lambda,ylim=range(lo95ci,hi95ci),type='b',xlab="year interval",ylab="lambda")
  lines(1:3,as.numeric(lo95ci),lty=2)
  lines(1:3,as.numeric(hi95ci),lty=2)
  abline(h=1,lty=3)
  title(paste(species.name,"\n",model.name))
}

# the function returns a reduced matrix collapsed using nday; if necessary, an X number of columns filled with NA are added
# to adjust the size of the shrinked matrix; be careful that nday makes sense for the size of the matrix, so that
# not many columns of NA are added 

shrink<-function(matrice,nday){
  dy<-nday
  while (dy < ncol(matrice)) {dy <- dy + nday}  
  addcol<-dy-ncol(matrice)
  if (addcol!=0) { 
    matNA<-matrix(NA,nrow=nrow(matrice),ncol=addcol)
    matrice<-data.frame(matrice,matNA)}    
  
  period<-ncol(matrice)/nday
  newday<-rep(1:period, each = nday)
  
  shr<-function (vec) {
    nav<-is.na(vec)
    dom<-all(nav==T)
    if(dom==T) {y<-NA}
    else {
      abb<-sum(vec,na.rm=T)
      y<-ifelse(abb==0,0,1)
    }
    return(y)
  }
  
  matday<-data.frame(newday,t(matrice))
  shrmat<-t(aggregate(matday[,-1],list(matday$newday),shr))
  
  return (shrmat[-1,]) 
}

#put together the pres/absence matrices for multiple years for a particular species
# starting with a list that has all matrices for each species for each year
f.multyear.sp<-function(LIST,spn){
  mats<-lapply(LIST,function(x) x[[spn]])
  res<-array(dim=c(dim(mats[[1]])[1],dim(mats[[1]])[2],length(mats)))
  for(i in 1:length(mats))
    res[,,i]<-mats[[i]]
  rownames(res)<-rownames(mats[[1]])
  res
}
#HELPER functions in WPI analysis and rare species analyses
#create some fake data for a species
#that is rare

#function to calculate the mode of a distribution
f.mode<-function(data,na.rm=T){
  qwe<-density(data,na.rm=T)
  qwe$x[which(qwe$y==max(qwe$y))]
  
}

#function to generate the WPI from the output simulations in JAGS
# psi is a three dimensional matrix with the psi of each species in each year
f.WPI <-function(psi){
  nsim <- dim(psi)[1]
  nyears <- dim(psi)[2]
  nsp <- dim(psi)[3]
  rel_psi<-numeric()
  wpi<-matrix(NA,nr=nsim,nc=nyears)
  for(i in 1:nsim){
    for(t in 1:nyears){
      for(s in 1:nsp){
        rel_psi[s] <- log(psi[i,t,s]/psi[i,1,s])
      }
      wpi[i,t]<-exp(1/nsp*sum(rel_psi))
    }
  }
  colnames(wpi)<-dimnames(psi)[[2]]
  wpi
  
}
#function to generate the WPI from the output simulations in JAGS
# psi is a three dimensional matrix with the psi of each species in each year
#this uses the odd ratio of psi/psi1 rather than the actual ration
f.WPI2 <-function(psi){
  nsim <- dim(psi)[1]
  nyears <- dim(psi)[2]
  nsp <- dim(psi)[3]
  rel_psi<-numeric()
  wpi<-matrix(NA,nr=nsim,nc=nyears)
  for(i in 1:nsim){
    for(t in 1:nyears){
      for(s in 1:nsp){
        rel_psi[s] <- log((psi[i,t,s]/(1-psi[i,t,s]+1/60/2))/(psi[i,1,s]/(1-psi[i,1,s]+1/60/2)))
      }
      wpi[i,t]<-exp(1/nsp*sum(rel_psi))
    }
  }
  colnames(wpi)<-dimnames(psi)[[2]]
  wpi
  
}
#graph the WPI through time with 95% confidence limits
#WPI is a matrix of n x t values (n = number of runs, t=number of years)
#calculate with mean, mode or median
graph.WPI <- function(wpi,fun=mean,title){
  require(TeachingDemos)
  require(ggplot2)
  year<-as.numeric(colnames(wpi))
  FUN<-match.fun(fun)
  ct<-apply(wpi,2,FUN,na.rm=T)
  #int<-apply(wpi,2,emp.hpd)
  lo50<-apply(wpi,2,quantile,0.25,na.rm=T)
  hi50<-apply(wpi,2,quantile,0.75,na.rm=T)
  conf75<-apply(wpi,2,quantile,c(0.125,1-0.125),na.rm=T)
  res<-data.frame(year=year,ct=ct,lo50=lo50,hi50=hi50,lo75=conf75[1,],hi75=conf75[2,])
  #res<-melt(res,id.vars=c('year'))
  
  p<-ggplot(data=res, aes(x=year))
  p<-p+geom_line(aes(y=ct),size=2)
  p<-p+geom_ribbon(aes(ymin=lo50,ymax=hi50),alpha=0.2)+geom_ribbon(aes(ymin=lo75,ymax=hi75),alpha=0.1)+xlab("Year")+ylab("Wildlife Picture Index")+labs(title="")+geom_hline(yintercept=1,size=0.5,linetype=2) +labs(title=title)+ylim(0,10)
  p
  
  #ggsave("SpeciesRichness.pdf",p,width=15,height=8,units="cm")
}

graph.psi <- function(psi,initial,fun=mean,title="",low=0.025,high=0.975,path=""){
  
  require(ggplot2)
  year<-as.numeric(colnames(psi))
  FUN<-match.fun(fun)
  ct<-apply(psi,2,FUN)
  lo<-apply(psi,2,quantile,low)
  hi<-apply(psi,2,quantile,high)
  naive<-initial
  #naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))
  res<-data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)
  #res<-melt(res,id.vars=c('year'))
  
  p<-ggplot(data=res, aes(x=year))
  p<-p+geom_line(aes(y=ct),size=2)+geom_point(aes(y=naive),size=3)
  p<-p+geom_ribbon(aes(ymin=lo,ymax=hi),alpha=0.2)+xlab("Year")+ylab("Occupancy")+ labs(title="")+ ylim(0,1)+labs(title=title)
  #p
  
  ggsave(paste(path,"/Occ_",title,".pdf",sep=""),p,width=15,height=8,units="cm")
}

graph.psi2 <- function(psifit,title){
  
  require(ggplot2)
  #year<-as.numeric(colnames(psi))
  #FUN<-match.fun(fun)
  #ct<-apply(psi,2,FUN)
  #lo<-apply(psi,2,quantile,0.025)
  #hi<-apply(psi,2,quantile,0.975)
  #naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))
  #res<-data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)
  #res<-melt(res,id.vars=c('year'))
  
  p<-ggplot(data=psifit, aes(x=year))
  p<-p+geom_line(aes(y=ct),size=2)+geom_point(aes(y=naive),size=3)
  p<-p+geom_ribbon(aes(ymin=lo,ymax=hi),alpha=0.2)+xlab("Year")+ylab("Occupancy")+ labs(title="")+ ylim(0,1)+labs(title=title)
  p
  
  #ggsave(paste("Occ_",title,".pdf",sep=""),p,width=15,height=8,units="cm")
}
#function to check for posterior predictive checks

f.ppc<-function(model){
  fit<-model$BUGSoutput$sims.list$fit
  fit.new<-model$BUGSoutput$sims.list$fit.new
  plot(fit,fit.new)
  abline(0,1)
  return(mean(fit.new>fit))
  
}
f.calc.psi<-function(psi,initial,fun=mean){
  year<-as.numeric(colnames(psi))
  FUN<-match.fun(fun)
  ct<-apply(psi,2,FUN)
  lo<-apply(psi,2,quantile,0.025)
  hi<-apply(psi,2,quantile,0.975)
  naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))
  data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)
  
}

f.load.fitted<-function(path){
  load(path)
  temp2<-temp
  temp2
}
#This function takes a wpi object (matrix of n iterations by y years)
# and calculates lambda with confidence limits
f.calc.lambda<-function(wpi){
  years<-dim(wpi)[2]
  lambda<-matrix(NA,nr=dim(wpi)[1],nc=years-1)
  for(i in 2:years)
    lambda[,i-1]<-wpi[,i]/wpi[,i-1]
  mean<-apply(lambda,2,mean)
  conf<-apply(lambda,2,quantile,c(0.025,0.975))
  data.frame(year=dimnames(wpi)[[2]][2:years],mean.lambda=mean,lo95=conf[1,],hi95=conf[2,])
  
}

extractSpeciesObsOcc <-function(list){
#Extract species observed occupancy from a list that has nyear elements
  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps 
years<-names(list)
sp.names<-names(list[[1]])  
n.years<-length(years)  
n.sp<-length(sp.names)

results.matrix<-matrix(NA,nr=n.sp,nc=n.years)
for (i in 1:n.years){
  results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateObsOcc))
  
}
colnames(results.matrix) <- years
rownames(results.matrix) <- sp.names
results.matrix

}

calculateObsOcc<-function(matrix){
  pres.abs<-apply(matrix,1,max,na.rm=T)
  pres.abs[is.infinite(pres.abs)] <- NA
  n.cam<-sum(!is.na(pres.abs))
  sum(pres.abs, na.rm=T)/n.cam
  
}
extractSpeciesDetections <-function(list){
  #Extract species detections from a list that has nyear elements
  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps 
  years<-names(list)
  sp.names<-names(list[[1]])  
  n.years<-length(years)  
  n.sp<-length(sp.names)
  
  results.matrix<-matrix(NA,nr=n.sp,nc=n.years)
  for (i in 1:n.years){
    results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateObsDet))
    
  }
  colnames(results.matrix) <- years
  rownames(results.matrix) <- sp.names
  results.matrix
  
}
calculateObsDet<-function(matrix){
  pres.abs<-apply(matrix,1,max,na.rm=T)
  pres.abs[is.infinite(pres.abs)] <- NA
  sum(pres.abs, na.rm=T)
  
}
extractNumCameraTraps <-function(list){
  #Extract number of camera traps used from a list that has nyear elements
  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps 
  years<-names(list)
  sp.names<-names(list[[1]])  
  n.years<-length(years)  
  n.sp<-length(sp.names)
  
  results.matrix<-matrix(NA,nr=n.sp,nc=n.years)
  for (i in 1:n.years){
    results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateNumCameraTraps))
    
  }
  colnames(results.matrix) <- years
  rownames(results.matrix) <- sp.names
  results.matrix
  
}
calculateNumCameraTraps<-function(matrix){
  pres.abs<-apply(matrix,1,max,na.rm=T)
  pres.abs[is.infinite(pres.abs)] <- NA
  sum(!is.na(pres.abs))
}

calculateWPIDiagnostics <- function(site.name){
# This function compares the observed occupancy with the fitted occupancy
# coming from the WPI analytics system
# It requires a vector with the names of the sites (site.names) and
# assumes that the whole camera trap data set is in the workspace (data)
  # and an object with the fitted results (wpi)
  results<-data.frame(site=character(),species=character(),
    tot.dets=numeric(),
    dets.per.year=numeric(),
    overall.occ=numeric(),
    diff.obs.mode=numeric(),
    diff.obs.median=numeric(),
    stringsAsFactors=F)     
#for(j in 1:length(site.names)){
  path<-as.character(site.name)
  dir.create(path)
  #Extract data for site j
  s.data<-subset(x=data,Site.Name==site.name,drop=T)
  # take care of some things with the data
  s.data<-f.fix.data2(s.data)
  nyears<-length(year<-sort(as.numeric(unique(s.data$Sampling.Period))))
  #create raw occupancy matrices
  mat<-list()
  for(i in 1:nyears)
    mat[[i]]<-f.matrix.creator2(s.data,year[i])  
  names(mat)<-year
  #Compress the matrices
  shmat<-list()
  for(i in 1:nyears)
    shmat[[i]]<-lapply(mat[[i]],FUN=f.shrink.matrix.to15)
  names(shmat)<-year
  #Extract species observed occupancy
  obs.occ.matrix<-extractSpeciesObsOcc(shmat)
  obs.det.matrix<-extractSpeciesDetections(shmat)
  obs.cams.matrix<-extractNumCameraTraps(shmat)
  
  #Extract a site and species and graph the results
  s.wpi<-subset(wpi,site_name==site.name,drop=T)
  #do it for one species
  
  s.sp.list<-unique(s.wpi$bin)

indx <- which(s.sp.list %in% rownames(obs.occ.matrix))
s.sp.list <- s.sp.list[indx] 
  
  
  for(i in 1:length(s.sp.list)){
    #i <- 1
    #j <- 5
    
    sp<-subset(x=s.wpi,bin==s.sp.list[i],drop=T)
    #turn into a matrix so I can graph it
    sp <- acast(sp, iteration~year, value.var="psi")
    #calculate mode, median and confidence intervals
    occ.mode<-apply(sp,2,f.mode)
    occ.median<-apply(sp,2,median)
    #lo<-apply(sp,2,quantile,c(0.1,0.9))
    #hi<-apply(sp,2,quantile,c(0.1,0.9))
    #calculate observed annual occupancy ()
    obs.occ <- obs.occ.matrix[s.sp.list[i],]
    #calculate observed number of detections per year
    obs.dets.per.year <- obs.det.matrix[s.sp.list[i],]
    #calculate total number of detections
    tot.dets <- sum(obs.det.matrix[s.sp.list[i],])
    #calculate mean number of detections
    dets.per.year <- tot.dets/nyears
    #calculate observed overall occupancy (for the whole time period)
    obs.all.occ <- sum(obs.det.matrix[s.sp.list[i],])/sum(obs.cams.matrix[s.sp.list[i],])
    #calculate distance between observed and fitted mode
    diff.obs.mode <- occ.mode - obs.occ
    #calculate distance between observed and fitted median
    diff.obs.median <- occ.median - obs.occ
    #calculate mean distance between observed and fitted mode
    mean.diff.obs.mode <- mean(diff.obs.mode, na.rm=T)
    #calculate mean distance between observed and fitted median
    mean.diff.obs.median <- mean(diff.obs.median, na.rm=T)
    #put everything together in a data frame
    temp <- c(as.character(site.name),s.sp.list[i], tot.dets,
              dets.per.year,
              obs.all.occ,
              mean.diff.obs.mode,
              mean.diff.obs.median)
    results[nrow(results)+1, ] <- temp                      
    
    graph.psi(title=paste(s.sp.list[i],"_",site.name),psi=sp,initial=obs.occ.matrix[s.sp.list[i],],fun=median,low=0.1,hi=0.9,path=path)
    print(paste("Done with species ",s.sp.list[i]))
  }
results
}